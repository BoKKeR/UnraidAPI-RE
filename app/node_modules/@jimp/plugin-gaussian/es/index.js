import { isNodePattern, throwError } from '@jimp/utils';
/**
 * Applies a true Gaussian blur to the image (warning: this is VERY slow)
 * @param {number} r the pixel radius of the blur
 * @param {function(Error, Jimp)} cb (optional) a callback for when complete
 * @returns {Jimp} this for chaining of methods
 */

export default (function () {
  return {
    gaussian: function gaussian(r, cb) {
      // http://blog.ivank.net/fastest-gaussian-blur.html
      if (typeof r !== 'number') {
        return throwError.call(this, 'r must be a number', cb);
      }

      if (r < 1) {
        return throwError.call(this, 'r must be greater than 0', cb);
      }

      var rs = Math.ceil(r * 2.57); // significant radius

      for (var y = 0; y < this.bitmap.height; y++) {
        for (var x = 0; x < this.bitmap.width; x++) {
          var red = 0;
          var green = 0;
          var blue = 0;
          var alpha = 0;
          var wsum = 0;

          for (var iy = y - rs; iy < y + rs + 1; iy++) {
            for (var ix = x - rs; ix < x + rs + 1; ix++) {
              var x1 = Math.min(this.bitmap.width - 1, Math.max(0, ix));
              var y1 = Math.min(this.bitmap.height - 1, Math.max(0, iy));
              var dsq = (ix - x) * (ix - x) + (iy - y) * (iy - y);
              var wght = Math.exp(-dsq / (2 * r * r)) / (Math.PI * 2 * r * r);

              var _idx = y1 * this.bitmap.width + x1 << 2;

              red += this.bitmap.data[_idx] * wght;
              green += this.bitmap.data[_idx + 1] * wght;
              blue += this.bitmap.data[_idx + 2] * wght;
              alpha += this.bitmap.data[_idx + 3] * wght;
              wsum += wght;
            }

            var idx = y * this.bitmap.width + x << 2;
            this.bitmap.data[idx] = Math.round(red / wsum);
            this.bitmap.data[idx + 1] = Math.round(green / wsum);
            this.bitmap.data[idx + 2] = Math.round(blue / wsum);
            this.bitmap.data[idx + 3] = Math.round(alpha / wsum);
          }
        }
      }

      if (isNodePattern(cb)) {
        cb.call(this, null, this);
      }

      return this;
    }
  };
});
//# sourceMappingURL=index.js.map