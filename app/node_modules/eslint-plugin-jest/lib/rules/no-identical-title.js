'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const _require = require('./util'),
      getDocsUrl = _require.getDocsUrl,
      isDescribe = _require.isDescribe,
      isTestCase = _require.isTestCase,
      isString = _require.isString,
      hasExpressions = _require.hasExpressions,
      getStringValue = _require.getStringValue;

const newDescribeContext = () => ({
  describeTitles: [],
  testTitles: []
});

const handleTestCaseTitles = (context, titles, node, title) => {
  if (isTestCase(node)) {
    if (titles.indexOf(title) !== -1) {
      context.report({
        message: 'Test title is used multiple times in the same describe block.',
        node
      });
    }

    titles.push(title);
  }
};

const handleDescribeBlockTitles = (context, titles, node, title) => {
  if (!isDescribe(node)) {
    return;
  }

  if (titles.indexOf(title) !== -1) {
    context.report({
      message: 'Describe block title is used multiple times in the same describe block.',
      node
    });
  }

  titles.push(title);
};

const isFirstArgValid = arg => {
  if (!arg || !isString(arg)) {
    return false;
  }

  if (arg.type === 'TemplateLiteral' && hasExpressions(arg)) {
    return false;
  }

  return true;
};

module.exports = {
  meta: {
    docs: {
      url: getDocsUrl(__filename)
    }
  },

  create(context) {
    const contexts = [newDescribeContext()];
    return {
      CallExpression(node) {
        const currentLayer = contexts[contexts.length - 1];

        if (isDescribe(node)) {
          contexts.push(newDescribeContext());
        }

        const _node$arguments = _slicedToArray(node.arguments, 1),
              firstArgument = _node$arguments[0];

        if (!isFirstArgValid(firstArgument)) {
          return;
        }

        const title = getStringValue(firstArgument);
        handleTestCaseTitles(context, currentLayer.testTitles, node, title);
        handleDescribeBlockTitles(context, currentLayer.describeTitles, node, title);
      },

      'CallExpression:exit'(node) {
        if (isDescribe(node)) {
          contexts.pop();
        }
      }

    };
  }

};