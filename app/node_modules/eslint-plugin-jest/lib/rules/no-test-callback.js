'use strict';

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance"); }

function _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

const _require = require('./util'),
      getDocsUrl = _require.getDocsUrl,
      isTestCase = _require.isTestCase;

module.exports = {
  meta: {
    docs: {
      url: getDocsUrl(__filename)
    },
    fixable: 'code'
  },

  create(context) {
    return {
      CallExpression(node) {
        if (!isTestCase(node) || node.arguments.length !== 2) {
          return;
        }

        const _node$arguments = _slicedToArray(node.arguments, 2),
              callback = _node$arguments[1];

        if (!/^(Arrow)?FunctionExpression$/.test(callback.type) || callback.params.length !== 1) {
          return;
        }

        const _callback$params = _slicedToArray(callback.params, 1),
              argument = _callback$params[0];

        context.report({
          node: argument,
          message: 'Illegal usage of test callback',

          fix(fixer) {
            const sourceCode = context.getSourceCode();
            const body = callback.body;
            const firstBodyToken = sourceCode.getFirstToken(body);
            const lastBodyToken = sourceCode.getLastToken(body);
            const tokenBeforeArgument = sourceCode.getTokenBefore(argument);
            const tokenAfterArgument = sourceCode.getTokenAfter(argument);
            const argumentInParens = tokenBeforeArgument.value === '(' && tokenAfterArgument.value === ')';
            let argumentFix = fixer.replaceText(argument, '()');

            if (argumentInParens) {
              argumentFix = fixer.remove(argument);
            }

            let newCallback = argument.name;

            if (argumentInParens) {
              newCallback = `(${newCallback})`;
            }

            let beforeReplacement = `new Promise(${newCallback} => `;
            let afterReplacement = ')';
            let replaceBefore = true;

            if (body.type === 'BlockStatement') {
              const keyword = callback.async ? 'await' : 'return';
              beforeReplacement = `${keyword} ${beforeReplacement}{`;
              afterReplacement += '}';
              replaceBefore = false;
            }

            return [argumentFix, replaceBefore ? fixer.insertTextBefore(firstBodyToken, beforeReplacement) : fixer.insertTextAfter(firstBodyToken, beforeReplacement), fixer.insertTextAfter(lastBodyToken, afterReplacement)];
          }

        });
      }

    };
  }

};